<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Perceptrón Visual</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      text-align: center;
      margin: 30px;
    }
    canvas {
      border: 1px solid #ccc;
      background-color: #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    label, input, select, button {
      margin: 5px;
      padding: 8px;
      font-size: 1rem;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    button {
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #45a049;
    }
    .visualization-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 40px;
      margin-top: 30px;
    }
    .perceptron-diagram svg {
      z-index: 1;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .neuron {
      fill: #e0e0e0;
      stroke: #666;
      stroke-width: 1;
      z-index: 2;
    }
    .neuron-label {
      font-size: 14px;
      font-weight: bold;
      fill: #333;
      pointer-events: none;
    }
    .connection {
      stroke: #555;
      stroke-width: 2;
    }
    svg {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Entrenamiento del Perceptrón</h1>

  <label for="modelo">Modelo:</label>
  <select id="modelo">
    <option value="simple">Perceptrón Simple</option>
    <option value="multicapa">Multicapa</option>
  </select><br>

  <label for="dataset">Selecciona un dataset:</label>
  <select id="dataset">
    <option value="and">AND</option>
    <option value="xor">XOR</option>
  </select><br>

  <label for="eta">Tasa de aprendizaje (η):</label>
  <input type="number" id="eta" step="0.01" value="0.1" /><br>

  <label for="cota">Cantidad máxima de iteraciones:</label>
  <input type="number" id="cota" value="100" /><br>

  <button id="btn-entrenar" onclick="iniciarEntrenamiento()">Iniciar entrenamiento</button>

  <p id="resultado"></p>

  <div class="visualization-container">
    <canvas id="grafico" width="400" height="400"></canvas>
    <div class="perceptron-diagram">
      <svg id="svg-diagram" width="300" height="200"></svg>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("grafico");
    const ctx = canvas.getContext("2d");

    const datasets = {
      and: {
        x: [[-1, 1], [1, -1], [-1, -1], [1, 1]],
        y: [-1, -1, -1, 1]
      },
      xor: {
        x: [[-1, 1], [1, -1], [-1, -1], [1, 1]],
        y: [1, 1, -1, -1]
      }
    };

    function signo(h) {
      return h >= 0 ? 1 : -1;
    }

    function dot(a, b) {
      return a.reduce((acc, val, i) => acc + val * b[i], 0);
    }

    function errorAbsoluto(x, y, w, modelo) {
      let error = 0;
      for (let i = 0; i < x.length; i++) {
        const entrada = [...x[i], 1];
        const salida = modelo === "simple" ?
          signo(dot(entrada, w)) :
          signo(dot([1, ...[signo(dot(entrada, w[0])), signo(dot(entrada, w[1]))]], w[2]));
        error += Math.abs(y[i] - salida);
      }
      return error;
    }

    function graficar(x, y, w, modelo) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(200, 200);
      ctx.scale(50, -50);

      ctx.beginPath();
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 0.01;
      for (let xg = -4; xg <= 4; xg++) {
        ctx.moveTo(xg, -4);
        ctx.lineTo(xg, 4);
      }
      for (let yg = -4; yg <= 4; yg++) {
        ctx.moveTo(-4, yg);
        ctx.lineTo(4, yg);
      }
      ctx.stroke();

      for (let i = 0; i < x.length; i++) {
        ctx.beginPath();
        ctx.arc(x[i][0], x[i][1], 0.15, 0, 2 * Math.PI);
        ctx.fillStyle = y[i] === 1 ? "#4CAF50" : "#F44336";
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 0.02;
        ctx.stroke();
      }

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 0.05;
      ctx.setLineDash([0.1, 0.1]);
      if (modelo === "simple" && w[1] !== 0) {
        ctx.beginPath();
        ctx.moveTo(-2, -(w[0] * -2 + w[2]) / w[1]);
        ctx.lineTo(2, -(w[0] * 2 + w[2]) / w[1]);
        ctx.stroke();
      } else if (modelo === "multicapa") {
        for (let j = 0; j < 2; j++) {
          if (w[j][1] !== 0) {
            ctx.beginPath();
            ctx.moveTo(-2, -(w[j][0] * -2 + w[j][2]) / w[j][1]);
            ctx.lineTo(2, -(w[j][0] * 2 + w[j][2]) / w[j][1]);
            ctx.stroke();
          }
        }
      }
      ctx.setLineDash([]);
      ctx.restore();
    }

    function actualizarSVG(modelo) {
      const svg = document.getElementById("svg-diagram");
      svg.innerHTML = "";

      if (modelo === "simple") {
        svg.innerHTML = `
          <line class="connection" x1="50" y1="50" x2="250" y2="100" />
          <line class="connection" x1="50" y1="100" x2="250" y2="100" />
          <line class="connection" x1="50" y1="150" x2="250" y2="100" />

          <circle class="neuron" cx="50" cy="50" r="20" />
          <circle class="neuron" cx="50" cy="100" r="20" />
          <circle class="neuron" cx="50" cy="150" r="20" />
          <circle class="neuron" cx="250" cy="100" r="20" />

          <text x="50" y="55" text-anchor="middle" class="neuron-label">x₁</text>
          <text x="50" y="105" text-anchor="middle" class="neuron-label">x₂</text>
          <text x="50" y="155" text-anchor="middle" class="neuron-label">1</text>
          <text x="250" y="105" text-anchor="middle" class="neuron-label">O</text>`;
      } else {
        svg.innerHTML = `
          <line class="connection" x1="50" y1="50" x2="150" y2="60" />
          <line class="connection" x1="50" y1="100" x2="150" y2="60" />
          <line class="connection" x1="50" y1="150" x2="150" y2="60" />
          <line class="connection" x1="50" y1="50" x2="150" y2="140" />
          <line class="connection" x1="50" y1="100" x2="150" y2="140" />
          <line class="connection" x1="50" y1="150" x2="150" y2="140" />

          <line class="connection" x1="150" y1="60" x2="250" y2="100" />
          <line class="connection" x1="150" y1="140" x2="250" y2="100" />

          <circle class="neuron" cx="50" cy="50" r="20" />
          <circle class="neuron" cx="50" cy="100" r="20" />
          <circle class="neuron" cx="50" cy="150" r="20" />
          <circle class="neuron" cx="150" cy="60" r="20" />
          <circle class="neuron" cx="150" cy="140" r="20" />
          <circle class="neuron" cx="250" cy="100" r="20" />

          <text x="50" y="55" text-anchor="middle" class="neuron-label">x₁</text>
          <text x="50" y="105" text-anchor="middle" class="neuron-label">x₂</text>
          <text x="50" y="155" text-anchor="middle" class="neuron-label">1</text>
          <text x="150" y="65" text-anchor="middle" class="neuron-label">h₁</text>
          <text x="150" y="145" text-anchor="middle" class="neuron-label">h₂</text>
          <text x="250" y="105" text-anchor="middle" class="neuron-label">O</text>`;
      }
    }

    async function perceptronSimple(x, y, eta, cota) {
      let w = [0, 0, 1];
      let error = Infinity, i = 0, errorMin = Infinity, wMin = [...w];
      const xExt = x.map(p => [...p, 1]);
      while (error > 0 && i < cota) {
        const idx = Math.floor(Math.random() * x.length);
        const salida = signo(dot(xExt[idx], w));
        const delta = xExt[idx].map(val => eta * (y[idx] - salida) * val);
        w = w.map((wi, j) => wi + delta[j]);
        error = errorAbsoluto(x, y, w, "simple");
        if (error < errorMin) [errorMin, wMin] = [error, [...w]];
        graficar(x, y, w, "simple");
        await new Promise(res => setTimeout(res, 150));
        i++;
      }
      graficar(x, y, wMin, "simple");
      document.getElementById("resultado").innerText = `Pesos finales: [${wMin.map(n => n.toFixed(2)).join(", ")}] con error ${errorMin}`;
    }

    async function perceptronMulticapa(x, y, eta, cota) {
      let w = [
        [Math.random(), Math.random(), Math.random()],
        [Math.random(), Math.random(), Math.random()]
      ];
      let wSalida = [Math.random(), Math.random(), Math.random()];
      let error = Infinity, i = 0, errorMin = Infinity;
      const xExt = x.map(p => [...p, 1]);
      let wMin = [JSON.parse(JSON.stringify(w)), [...wSalida]];

      while (error > 0 && i < cota) {
        const idx = Math.floor(Math.random() * x.length);
        const h = w.map(wi => signo(dot(xExt[idx], wi)));
        const hExt = [1, ...h];
        const salida = signo(dot(hExt, wSalida));

        const deltaSalida = hExt.map(val => eta * (y[idx] - salida) * val);
        wSalida = wSalida.map((w, j) => w + deltaSalida[j]);

        for (let j = 0; j < w.length; j++) {
          const delta = xExt[idx].map(val => eta * (y[idx] - salida) * wSalida[j + 1] * val);
          w[j] = w[j].map((wj, k) => wj + delta[k]);
        }

        error = errorAbsoluto(x, y, [w[0], w[1], wSalida], "multicapa");
        if (error < errorMin) {
          errorMin = error;
          wMin = [JSON.parse(JSON.stringify(w)), [...wSalida]];
        }

        graficar(x, y, [w[0], w[1]], "multicapa");
        await new Promise(res => setTimeout(res, 150));
        i++;
      }
      graficar(x, y, [wMin[0][0], wMin[0][1]], "multicapa");
      document.getElementById("resultado").innerText = `Pesos ocultos: ${JSON.stringify(wMin[0])}, salida: ${wMin[1].map(x => x.toFixed(2))} con error ${errorMin}`;
    }

    function iniciarEntrenamiento() {
      const tipo = document.getElementById("dataset").value;
      const eta = parseFloat(document.getElementById("eta").value);
      const cota = parseInt(document.getElementById("cota").value);
      const modelo = document.getElementById("modelo").value;

      actualizarSVG(modelo);

      const datos = datasets[tipo];
      if (modelo === "simple") {
        perceptronSimple(datos.x, datos.y, eta, cota);
      } else {
        perceptronMulticapa(datos.x, datos.y, eta, cota);
      }
    }
  </script>
</body>
</html>
